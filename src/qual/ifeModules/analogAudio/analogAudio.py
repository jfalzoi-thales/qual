import subprocess
from common.gpb.python.AnalogAudio_pb2 import AnalogAudioRequest, AnalogAudioResponse
from common.tzmq.ThalesZMQMessage import ThalesZMQMessage
from common.module.module import Module

## AnalogAudio Module Class
class IFEAnalogAudio(Module):
    ## Constructor
    #  @param   self
    #  @param   config  Configuration for this module instance
    def __init__(self, config = None):
        #  Initializes parent class
        super(IFEAnalogAudio, self).__init__(config)
        #  Dict containing
        self.connections = {}
        #  Add handler to available message handlers
        self.addMsgHandler(AnalogAudioRequest, self.handler)

    ## Handles incoming messages
    #  Receives tzmq request and runs requested process
    #  @param   self
    #  @param   msg   tzmq format message
    #  @return  AnalogAudioResponse object
    def handler(self, msg):
        response = AnalogAudioResponse()

        if msg.body.requestType == AnalogAudioRequest.RUN:
            self.start(response)
        elif msg.body.requestType == AnalogAudioRequest.STOP:
            self.stop(response)
        elif msg.body.requestType == AnalogAudioRequest.REPORT:
            self.report(response)
        else:
            self.log.error("Unexpected Request Type %d" %(msg.body.requestType))

        return ThalesZMQMessage(response)

    ## Runs demo_serial485 to exercise the AnalogAudio peripheral
    #  @param   self
    def startDemoSerial(self):
        try:
            self.demo = subprocess.check_output(
            ["demo_serial485", "ar485LoopbackTest2", str(self.baudrate), str(self.bytesize), str(self.stopbits),
             self.parity, "1"])
        except subprocess.CalledProcessError as e:
            if "Interrupted system call" in e.output:
                self.log.debug("demo_serial485 stopped")
            else:
                self.log.error("Error running demo_serial485: %s" % e.output)

            self.demo = ""


    ## Runs in thread to continually run and gather demo_serial485 data
    #  @param   self
    def demoSerialTracker(self):
        self.startDemoSerial()
        lines = self.demo.splitlines()

        for line in lines:
            #  Check that current line is not header
            if line.startswith("Master-"):
                fields = line.split()
                #  Port is listed after 'Master-', so split by Master and take 2nd (1st element is blank due to split) element
                port = fields[0].split("Master-")[1]

                if fields[2] == "0":
                    self.missed[port] += 1
                elif fields[2] == "1":
                    self.received[port] += 1
                else:
                    self.log.error("Unexpected output: %s" % line)

    ## Starts demo_serial485 to test the AnalogAudio pripheral
    #  @param   self
    #  @param   response    A AnalogAudioResponse object generated by report() function
    def start(self, response):
        if not self._running:
            #  Kills any stray demo_serial485 instances and waits for pkill to complete
            subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
            self.startThread()
        else:
            for port in self.ports:
                self.missed[port] = 0
                self.received[port] = 0

        self.report(response)

    ## Stops demo_serial485 instance
    #  @param   self
    #  @param   response  A AnalogAudioResponse object generated by report() function
    def stop(self, response):
        self._running = False
        subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
        self.stopThread()
        self.report(response)

        for port in self.ports:
            self.missed[port] = 0
            self.received[port] = 0

    ## Reports statistics gathered from demo_serial485
    #  @param   self
    #  @param   response  A AnalogAudioResponse object
    def report(self, response):
        response.state = AnalogAudioResponse.RUNNING if self._running else AnalogAudioResponse.STOPPED

        for port in self.ports:
            stats = response.statistics.add()
            stats.channel = port
            stats.missed = self.missed[port]
            stats.received = self.received[port]

    ## Attempts to terminate module gracefully
    #  @param   self
    def terminate(self):
        self._running = False
        subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
        self.stopThread()