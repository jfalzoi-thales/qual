import subprocess
from common.gpb.python.ARINC485_pb2 import ARINC485Request, ARINC485Response
from common.tzmq.ThalesZMQMessage import ThalesZMQMessage
from common.module.module import Module

## ARINC485 Module Class
class ARINC485(Module):
    ## Constructor
    #  @param   self
    #  @param   config  Configuration for this module instance
    def __init__(self, config = None):
        #  Initializes parent class
        super(ARINC485, self).__init__(config)
        ## Baudrate for demo_serial485, which is one of 2400, 9600, or 115200
        self.baudrate = 9600
        ## Parity for demo_serial485, which is one of N, O, or E
        self.parity = 'N'
        ## Stopbits for demo_serial485, which is one of 1 or 2
        self.stopbits = 1
        ## Byesize (Databits) for demo_serial485, which is one of 7 or 8
        self.bytesize = 8
        #  Use config file values if available
        self.loadConfig(attributes=('baudrate', 'parity', 'stopbits', 'bytesize'))
        ## Keys for iterating over dictionaries
        self.ports = ["Slave1", "Slave2", "Slave3", "Slave4", "Slave5"]
        ## Dictionary of missed counters, by port
        self.missed = {port:0 for port in self.ports}
        ## Dictionary of received counters, by port
        self.received = {port:0 for port in self.ports}
        ## Output from most recent run of demo_serial485
        self.demo = None
        #  Add thread to run demo_serial485
        self.addThread(self.demoSerialTracker)
        #  Add handler to available message handlers
        self.addMsgHandler(ARINC485Request, self.handler)

    ## Handles incoming messages
    #  Receives tzmq request and runs requested process
    #  @param   self
    #  @param   msg   tzmq format message
    #  @return  ARINC485Response object
    def handler(self, msg):
        response = ARINC485Response()

        if msg.body.requestType == ARINC485Request.RUN:
            self.start(response)
        elif msg.body.requestType == ARINC485Request.STOP:
            self.stop(response)
        elif msg.body.requestType == ARINC485Request.REPORT:
            self.report(response)
        else:
            self.log.error("Unexpected Request Type %d" %(msg.body.requestType))

        return ThalesZMQMessage(response)

    ## Runs demo_serial485 to exercise the ARINC485 peripheral
    #  @param   self
    def startDemoSerial(self):
        try:
            self.demo = subprocess.check_output(
            ["demo_serial485", "ar485LoopbackTest2", str(self.baudrate), str(self.bytesize), str(self.stopbits),
             self.parity, "1"])
        except subprocess.CalledProcessError as e:
            if "Interrupted system call" in e.output:
                self.log.debug("demo_serial485 stopped")
            else:
                self.log.error("Error running demo_serial485: %s" % e.output)

            self.demo = ""


    ## Runs in thread to continually run and gather demo_serial485 data
    #  @param   self
    def demoSerialTracker(self):
        self.startDemoSerial()
        lines = self.demo.splitlines()

        for line in lines:
            #  Check that current line is not header
            if line.startswith("Master-"):
                fields = line.split()
                #  Port is listed after 'Master-', so split by Master and take 2nd (1st element is blank due to split) element
                port = fields[0].split("Master-")[1]

                if fields[2] == "0":
                    self.missed[port] += 1
                elif fields[2] == "1":
                    self.received[port] += 1
                else:
                    self.log.error("Unexpected output: %s" % line)

    ## Starts demo_serial485 to test the ARINC485 pripheral
    #  @param   self
    #  @param   response    A ARINC485Response object generated by report() function
    def start(self, response):
        if not self._running:
            #  Kills any stray demo_serial485 instances and waits for pkill to complete
            subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
            self.startThread()
        else:
            for port in self.ports:
                self.missed[port] = 0
                self.received[port] = 0

        self.report(response)

    ## Stops demo_serial485 instance
    #  @param   self
    #  @param   response  A ARINC485Response object generated by report() function
    def stop(self, response):
        self._running = False
        subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
        self.stopThread()
        self.report(response)

        for port in self.ports:
            self.missed[port] = 0
            self.received[port] = 0

    ## Reports statistics gathered from demo_serial485
    #  @param   self
    #  @param   response  A ARINC485Response object
    def report(self, response):
        response.state = ARINC485Response.RUNNING if self._running else ARINC485Response.STOPPED

        for port in self.ports:
            stats = response.statistics.add()
            stats.channel = port
            stats.missed = self.missed[port]
            stats.received = self.received[port]

    ## Attempts to terminate module gracefully
    #  @param   self
    def terminate(self):
        self._running = False
        subprocess.Popen(["pkill", "-9", "demo_serial485"]).communicate()
        self.stopThread()