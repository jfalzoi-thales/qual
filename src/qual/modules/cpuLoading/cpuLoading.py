import subprocess
import os
from common.gpb.python.CPULoading_pb2 import CPULoadingRequest, CPULoadingResponse
from common.tzmq.ThalesZMQMessage import ThalesZMQMessage
from common.module.module import Module, ModuleException
from cpuLoader import CPULoader

## CPU Loading Module Exception Class
class CPULoadingModuleException(ModuleException):
    def __init__(self, msg):
        super(CPULoadingModuleException, self).__init__()
        self.msg = msg

## CPU Loading Module Class
class CPULoading(Module):
    ## Constructor
    #  @param   self
    #  @param   config  Configuration for this module instance
    def __init__(self, config = {}):
        #  Initializes parent class
        super(CPULoading, self).__init__({})

        #  Check for existence of lookbusy executable
        if not os.path.exists("/usr/local/bin/lookbusy"):
            raise CPULoadingModuleException("Unable to locate lookbusy executable")

        ## Indicates whether or not a CPU load has been set
        self.active = False
        ## CPULoader thread which continually gathers CPU load information
        self.loader = CPULoader()
        ## Starts CPULoader thread
        self.loader.start()
        ## Adds handler to available message handlers
        self.addMsgHandler(CPULoadingRequest, self.handler)

    ## Handles incoming messages
    #  Receives tzmq request and runs requested process
    #  @param   self
    #  @param   msg   tzmq format message
    #  @return  A CPULoadingResponse object
    def handler(self, msg):
        response = CPULoadingResponse()

        if msg.body.requestType == CPULoadingRequest.RUN:
            if msg.body.level != 0:
                self.start(response, msg.body.level)
            else:
                self.start(response)
        elif msg.body.requestType == CPULoadingRequest.STOP:
            self.stop(response)
        elif msg.body.requestType == CPULoadingRequest.REPORT:
            self.report(response)
        else:
            self.log.error("Unexpected Request Type %d" %(msg.body.requestType))

        return ThalesZMQMessage(response)

    ## Starts lookbusy process to mimic specific CPU loads
    #  Uses console commands to remove previous lookbusy instances, starts a new CPU load, and reports current CPU load
    #  @param   self
    #  @param   response    A CPULoadingResponse object generated by report() function
    #  @param   level       Integer to specify percentage of CPU load [DEFAULT = 80]
    def start(self, response, level = 80):
        if level in range(0, 100):
            self.active = True
            #  Kills any stray lookbusy instances and waits for pkill to complete
            subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()
            #  Starts lookbusy instance
            subprocess.Popen(["/usr/local/bin/lookbusy", "-qc", str(int(level))])
        else:
            self.log.error("Unexpected Value %d" %(level))

        self.report(response)

    ## Stops CPU load from lookbusy instances
    #  Uses console commands to remove lookbusy instances and reports current CPU load
    #  @param   self
    #  @param   response  A CPULoadingResponse object generated by report() function
    def stop(self, response):
        self.active = False
        #  Kills lookbusy instances and waits for pkill to complete
        subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()
        self.report(response)

    ## Reports current CPU load information provided by linux
    #  Polls CPULoader thread for CPU load information and creates CPULoadingResponse object
    #  @param   self
    #  @param   response  A CPULoadingResponse object
    def report(self, response):
        results = self.loader.getcpuload()

        if self.active:
            response.state = CPULoadingResponse.RUNNING
        else:
            response.state = CPULoadingResponse.STOPPED

        if results != {}:
            response.totalUtilization = results["cpu"]
        else:
            self.log.error("Missing CPU Data")

        for key, value in results.items():
            if key != "cpu":
                response.coreUtilization.append(value)

    ## Attempts to terminate module gracefully
    #  @param   self
    def terminate(self):
        subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()
        self.loader.quit = True
        self.active = False