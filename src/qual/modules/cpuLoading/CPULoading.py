from time import sleep
import subprocess
import os
from common.gpb.python import CPULoading_pb2
from common.tzmq.ThalesZMQMessage import ThalesZMQMessage
from common.module.module import Module, ModuleException
import CPULoader


## CPU Loading Module Exception Class
class CPULoadingModuleException(ModuleException):
    def __init__(self, msg):
        super(CPULoadingModuleException, self).__init__()
        self.msg = msg


## CPU Loading Module Class
class CPULoading(Module):
    ## Constructor
    #  @param     self
    #  @param     config  Configuration for this module instance
    def __init__(self, config = {}):
        # initializes parent class
        super(CPULoading, self).__init__({})

        # check for existence of lookbusy executable
        if not os.path.exists("/usr/local/bin/lookbusy"):
            raise CPULoadingModuleException("Unable to locate lookbusy executable")

        ## indicates whether or not a CPU load has been set
        self.active = False
        ## CPULoader thread which continually gathers CPU load information
        self.loader = CPULoader.CPULoader()

        ## starts CPULoader thread
        self.loader.start()
        ## adds handler to available message handlers
        self.addMsgHandler(CPULoading_pb2.CPULoadingRequest, self.handler)

    ## Handles incoming messages
    #
    #  Receives tzmq request and runs requested process
    #
    #  @param     self
    #  @param     msg       tzmq format message
    #  @return    reply     a CPULoadingResponse object
    def handler(self, msg):
        reply = CPULoading_pb2.CPULoadingResponse()

        if msg.body.requestType == CPULoading_pb2.CPULoadingRequest.RUN:
            if msg.body.level != 0:
                reply = self.start(msg.body.level)
            else:
                reply = self.start()
        elif msg.body.requestType == CPULoading_pb2.CPULoadingRequest.STOP:
            reply = self.stop()
        elif msg.body.requestType == CPULoading_pb2.CPULoadingRequest.REPORT:
            reply = self.report()
        else:
            self.log.error("Unexpected Request Type %d" %(msg.body.requestType))

        return ThalesZMQMessage(reply)

    ## Starts lookbusy process to mimic specific CPU loads
    #
    #  Uses console commands to remove previous lookbusy instances, starts a new CPU load, and reports current CPU load
    #
    #  @param     self
    #  @param     level         integer to specify percentage of CPU load [DEFAULT = 80]
    #  @return    self.report() a CPULoadingResponse object generated by report() function
    def start(self, level = 80):
        if level in range(0, 100):
            self.active = True

            ## kills any stray lookbusy instances and waits for pkill to complete
            subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()

            ## starts lookbusy instance
            subprocess.Popen(["/usr/local/bin/lookbusy", "-qc", str(int(level))])
        else:
            self.log.error("Unexpected Value %d" %(level))

        return self.report()

    ## Stops CPU load from lookbusy instances
    #
    #  Uses console commands to remove lookbusy instances and reports current CPU load
    #
    #  @param     self
    #  @return    self.report() a CPULoadingResponse object generated by report() function
    def stop(self):
        self.active = False
        ## kills lookbusy instances and waits for pkill to complete
        subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()

        return self.report()

    ## Reports current CPU load information provided by linux
    #
    #  Polls CPULoader thread for CPU load information and creates CPULoadingResponse object
    #
    #  @param     self
    #  @return    loadResponse     a CPULoadingResponse object
    def report(self):
        results = self.loader.getcpuload()
        loadResponse = CPULoading_pb2.CPULoadingResponse()

        if self.active:
            loadResponse.state = CPULoading_pb2.CPULoadingResponse.RUNNING
        else:
            loadResponse.state = CPULoading_pb2.CPULoadingResponse.STOPPED

        if results != {}:
            loadResponse.totalUtilization = results["cpu"]

        for key, value in results.items():
            if key != "cpu":
                loadResponse.coreUtilization.append(value)

        return loadResponse

    ## Attempts to terminate module gracefully
    #
    #  Kills lookbusy processes, sends quit flag to CPULoader thread, and exits module
    #
    #  @param     self
    #  @return    loadResponse     a CPULoadingResponse object
    def terminate(self):
        subprocess.Popen(["pkill", "-9", "lookbusy"]).communicate()
        self.loader.quit = True
        self.active = False
        sleep(2)